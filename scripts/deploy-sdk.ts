import {
  Client,
  AccountId,
  PrivateKey,
  ContractCreateFlow,
  ContractFunctionParameters,
  Hbar,
  ContractCallQuery,
  AccountBalanceQuery
} from '@hashgraph/sdk';
import * as fs from 'fs';
import * as path from 'path';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

/**
 * Deploy CertificateNFT contract to Hedera using Hedera SDK
 * Following official Hedera documentation patterns
 */
async function deployContract() {
  console.log('üöÄ Starting Hedera Contract Deployment...');
  
  // Validate environment variables
  const operatorId = process.env.OPERATOR_ID || process.env.ACCOUNT_ID;
  const operatorKey = process.env.OPERATOR_KEY || process.env.PRIVATE_KEY;
  
  if (!operatorId || !operatorKey) {
    throw new Error('‚ùå Missing OPERATOR_ID and OPERATOR_KEY in environment variables');
  }

  // Initialize Hedera client for testnet
  const client = Client.forTestnet();
  client.setOperator(AccountId.fromString(operatorId), PrivateKey.fromString(operatorKey));
  
  // Set default max transaction fee and gas
  client.setDefaultMaxTransactionFee(new Hbar(100));
  client.setDefaultMaxQueryPayment(new Hbar(50));

  console.log(`üìù Deploying with account: ${operatorId}`);

  // Check account balance
  const balance = await new AccountBalanceQuery()
    .setAccountId(operatorId)
    .execute(client);
  
  console.log(`üí∞ Account balance: ${balance.hbars.toString()}`);

  if (balance.hbars.toBigNumber().isLessThanOrEqualTo(0)) {
    throw new Error('‚ùå Account has no HBAR. Please fund your account first.');
  }

  try {
    // Read the compiled contract bytecode
    // For now, we'll use ContractCreateFlow which handles file creation automatically
    const contractBytecode = getContractBytecode();
    
    console.log('üì¶ Creating contract...');
    
    // Method 1: Using ContractCreateFlow (Recommended for Hedera)
    const contractCreateFlow = new ContractCreateFlow()
      .setBytecode(contractBytecode)
      .setGas(1000000) // Set gas limit
      .setConstructorParameters(
        new ContractFunctionParameters()
          .addAddress(AccountId.fromString(operatorId).toSolidityAddress()) // Initial owner
      );

    const contractCreateSubmit = await contractCreateFlow.execute(client);
    const contractCreateReceipt = await contractCreateSubmit.getReceipt(client);
    const contractId = contractCreateReceipt.contractId;
    const contractAddress = contractId?.toSolidityAddress();

    console.log('‚úÖ Contract deployed successfully!');
    console.log(`üìÑ Contract ID: ${contractId}`);
    console.log(`üìç Contract Address: ${contractAddress}`);
    console.log(`üîó View on HashScan: https://hashscan.io/testnet/contract/${contractId}`);

    // Update environment file with contract address
    updateEnvironmentFile(contractAddress);

    // Verify contract deployment
    await verifyContract(client, contractId);

    console.log('\nüéâ Deployment completed successfully!');
    console.log('üìã Next steps:');
    console.log('1. Update your frontend .env file with the contract address');
    console.log('2. Test the certificate issuance functionality');
    console.log('3. Deploy to mainnet when ready for production');
    
    return {
      contractId: contractId?.toString(),
      contractAddress,
      transactionId: contractCreateSubmit.transactionId.toString()
    };

  } catch (error) {
    console.error('‚ùå Deployment failed:', error);
    throw error;
  } finally {
    client.close();
  }
}

/**
 * Get contract bytecode - for now return placeholder
 * In a full setup, this would read from compiled Solidity
 */
function getContractBytecode(): Uint8Array {
  // This is a placeholder - in a real deployment, you would:
  // 1. Compile the Solidity contract using solc or Hardhat
  // 2. Read the bytecode from the compilation output
  // 3. Return the bytecode as Uint8Array
  
  // For this example, we'll provide instructions to get bytecode
  const message = `
‚ùå Contract bytecode not found.

To get the bytecode for deployment:

OPTION 1: Use Remix IDE (Recommended)
1. Go to https://remix.ethereum.org/
2. Create CertificateNFT.sol with our contract code
3. Compile the contract
4. Copy the bytecode from the compilation artifacts
5. Save it to a file and update this script

OPTION 2: Use Hardhat
1. Run: npx hardhat compile
2. Read bytecode from: artifacts/contracts/CertificateNFT.sol/CertificateNFT.json
3. Extract the 'bytecode' field

OPTION 3: Use solc directly
1. Install solc: npm install -g solc
2. Compile: solc --bin contracts/CertificateNFT.sol
3. Use the generated bytecode

Please compile the contract first and update this script with the bytecode.
`;

  console.log(message);
  throw new Error('Contract bytecode not available. Please compile the contract first.');
}

/**
 * Update environment file with deployed contract address
 */
function updateEnvironmentFile(contractAddress: string | undefined) {
  if (!contractAddress) {
    console.warn('‚ö†Ô∏è No contract address to update in environment file');
    return;
  }

  try {
    const envPath = path.resolve('.env');
    let envContent = fs.readFileSync(envPath, 'utf8');
    
    // Update or add the testnet contract address
    if (envContent.includes('VITE_CONTRACT_ADDRESS_TESTNET=')) {
      envContent = envContent.replace(
        /VITE_CONTRACT_ADDRESS_TESTNET=.*/,
        `VITE_CONTRACT_ADDRESS_TESTNET=${contractAddress}`
      );
    } else {
      envContent += `\nVITE_CONTRACT_ADDRESS_TESTNET=${contractAddress}`;
    }
    
    fs.writeFileSync(envPath, envContent);
    console.log(`üìù Updated .env with contract address: ${contractAddress}`);
  } catch (error) {
    console.error('‚ùå Failed to update environment file:', error);
  }
}

/**
 * Verify contract deployment by calling a read function
 */
async function verifyContract(client: Client, contractId: AccountId | null) {
  if (!contractId) {
    console.warn('‚ö†Ô∏è No contract ID to verify');
    return;
  }

  try {
    console.log('üîç Verifying contract deployment...');
    
    // Try to call the name() function to verify the contract is working
    const contractCallQuery = new ContractCallQuery()
      .setContractId(contractId)
      .setGas(100000)
      .setFunction('name');
    
    const contractCallResult = await contractCallQuery.execute(client);
    const name = contractCallResult.getString(0);
    
    console.log(`‚úÖ Contract verification successful! Contract name: ${name}`);
  } catch (error) {
    console.warn('‚ö†Ô∏è Contract verification failed (this is normal for new deployments):', error);
  }
}

// Run deployment
if (require.main === module) {
  deployContract()
    .then((result) => {
      console.log('üéâ Deployment result:', result);
      process.exit(0);
    })
    .catch((error) => {
      console.error('‚ùå Deployment failed:', error);
      process.exit(1);
    });
}

export { deployContract };